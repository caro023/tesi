\chapter{Teraflow}
Il controller SDN su cui ci focalizzeremo è TeraFlow \cite{TeraFlow}. 
\\TeraFlow è stato finanziato dall'unione europea per il programma di ricerca e innovazione Horizon 2020 \cite{Horizon}. 
%Nonostante la quantità di controller SDN i fondatori di TeraFlow hanno riscontrato che molte delle soluzioni attuali sono costituite da un software monolitoco
%in grado di sincronizzarsi con altri controller SDN distribuiti tramite protocolli specifici.
%Il problema principale dei controller SDN `e il basso numero di contribuzioni che negli ul-timi anni o mesi si stanno sempre di pi`u diradando
Nonostante la quantità di controller SDN i fondatori di TeraFlow hanno riscontrato come problema comune il basso numero di contribuzioni che negli ultimi anni o mesi si stanno sempre di più diradando. 
Ciò ha come conseguenza che i nuovi bisogni e requisiti delle reti moderne che si stanno sviluppando in questo momento non saranno supportati.
\\L'obiettivo di TeraFlow è implementare un controller che soddisfi i requisiti attuali ed eventualmente futuri, sia architetturali che infrastrutturali, per le reti. 
Per raggiungere questo scopo è necessaria una contribuzione attiva 
%(active develop) 
da parte degli utenti, per questo TeraFlow è un progetto OpenSource 
al quale tutti i membri della comunità ETSI (European Telecommunications Standard Institute) \cite{etsi} possono contribuire. 
Un altro proposito è di riuscire a diminuire il gap tra ciò che le industrie richiedono e ciò che si può ricavare dagli standard SDN.
Questo controller, che è ancora in fase di sviluppo, sarà in grado di integrarsi con gli attuali framework NFV e MEC e fornire l'integrazione delle 
apparecchiature di rete ottica e a microonde.
\\TeraFlow segue un'architettura nativa cloud, è basato su container sviluppati sopra un ambiente basato su Kubernetes presso la sede del CTTC a Barcellona che garantiscono scalabilità, dinamicità e integrità.
Ogni container, o componente, ha delle responsabilità e definisce un microservizio che interagisce con gli altri attraverso la connessione di rete rendendo il controller disaggregato.
Le componenti principali sono implementate in Java (solo quelle di Automation e Policy) e Python.
I servizi sono semplici e dettagliati rendendo possibile l'uso di protocolli leggeri.
Dal punto di vista della sicurezza utilizza un sistema di Machine Learning per la prevenzione e la mitigazione di attacchi.
\begin{figure}[h]
    \centering
   \includegraphics[width=1\textwidth]{architetturatf.png}
    \caption{Architettura di TeraFlow}
    \label{fig:tfs}
\end{figure}

%L'architettura è basata su microservizi interconnessi da un bus grpc.
\section{Componenti}
TeraFlow utilizza un bus gRPC(Google Remote Procedure Call) per comunicare tra le componenti. 
E' stato scelto come protocollo interno di TeraFlow, al posto di REST, per i modi più concreti di descrivere l'interazione tra due entità.
La descrizione di messaggi condivisi è specificata usando dei Protocol Buffers nei quali è descritto lo schema dei messaggi che le componenti si scambiano, quindi i vari servizi che implementano con le adeguate funzioni da usare. 
I Protocol Buffer sono un meccanismo indipendente sia dalla piattaforma che dal linguaggio per la serializzazione di strutture dati. Ogni componente ne possiede uno e sono descritti nella pagina del sito \cite{ProtoBuf}.

\section{Device Level Abstraction}
Il Device Level Abstraction fornisce la capacità di interagire con i dispositivi presenti all'interno della rete e corrisponde all'Infrastructure layer descritto nell'architettura SDN \ref{ch:SDN}.
Una componente necessaria per questo livello di astrazione è la componente SBI.
Per far comunicare più tipi di device possibili con il controller la componente presenta eterogeneità offrendo supporto a differenti protocolli.
Il suo compito principale è effettuare l'handshake con i device in modo da introdurli nell'ecosistema del controller
e essere in grado di configurarli a runtime. 
Dopo aver effettuato la connessione con un determinato device e essersi assicurata la disponibilità,
la componente presenta una API che permette di mandare in input le configurazioni scelte attraverso un file JSON al controller TeraFlow. 
Il controller provvederà a inserire le giuste entry nella tabella del relativo switch o router.
%Per questo viene introdotta la componente di monitoring che servirà da supporto per il Management-level Abstraction.
%che interagisce con la il network equipment attraverso pluggable drivers.
%OpenFlowOpenConfig-based routers
\\Un'altra componente che fa parte di questo livello è quella di monitoring il cui compito è offrire supporto al Management-level.
E' essenziale per l'automazione dei servizi e per prendere le decisioni a run time sulla base di eventi.
La componente interagisce con i device per catturare lo stato della rete sttraverso delle kpi e persiste le informazioni all'interno di database necessari per esporle e renderle utilizzabili ad altre componenti.
Quando si tratta di topologie più ampie, dovendo gestire molti device, serve però un livello di astrazione superiore per specificare la connessione tra vari end-points, a tal fine si introduce il Service-level. 
\section{Service Level Abstraction}
Il compito principale del Service Level sono i servizi. 
Questo nuovo livello di astrazione permette a un utente di definire intenti per la connessione tra gli end-points grazie alla componente di Service.
Un utente può selezionare un path scelto o chiedere al controller di determinarne uno che rispetti determinati requisiti. La componente che si occupa di calcolare una serie di 
path tra gli end-points è la PathComp. 
Per astrarre la complessità del livello sottostante all'utente la componente di service è in grado di tradurre l'intento in un insieme di regole che propaga all'SBI (sempre attraverso file JSON)
cosicchè venga configurato ogni device all'interno del percorso per stabilire la connessione.

\section{Management Level Abstraction}
Questo livello di astrazione è stato introdotto per poter interagire con la componente di service dinamicamente per creare, aggiorare o eliminare un servizio sulla base degli eventi che derivano dallo stato della rete.
Una delle componenti che ne fanno parte è la componente di Policy. Si occupa di creare un service level agreement (SLA) per uno specifico servizio identificato tramite un id.
Specifica delle condizioni che devono essere rispettate chiedendo alla componente di Monitoring di notificare con un allarme quando non saranno più soddisfatte.
A questo punto verrà creato un evento e si eseguiranno delle azioni prestabilite dal controller fino ai dispositivi per gestire i problemi o cambiare il servizio. 
Solitamente le azioni contemplano l'interazione con altre componenti al livello inferiore.
Un'esempio può essere una notifica alla componente di Service che si occuperà di modificare il percorso identificato precedentemente per far rispettare nuovamente i requisiti.


%\section {Hackfest }
\section{gRPC}
GRPC è un protocollo basato sul protocollo di trasporto HTTP/2 che utilizza la codifica orientata ai byte introducendo così bassa latenza.
E' progettato per trasportare messaggi peer-to-peer in modo distribuito e non durevole consentendo a più servizi lo scambio di informazioni attraverso un bus condiviso.